- style: clay
  title: Function Oriented JavaScript
  notes: |
    I call this talk "Function Oriented JavaScript", but we're really going to be looking at other
    functional languages and attempting to extract good habits from them and apply them to JavaScript.

- image: images/moores-law.jpg

- heading: λ
  code:
    - (Haskell)
    - lambda.hs
    - (Clojure)
    - lambda.clj
    - (Erlang)
    - lambda.erl

- heading: λ
  code:
    - (Ruby 1.9)
    - lambda.rb
    - (Python 3)
    - lambda.py

- heading: λ
  code:
    - (Java 8)
    - lambda.java
    - (C♯)
    - lambda.cs

- heading: λ
  code:
    - (JavaScript)
    - lambda.js
    - (JavaScript - ECMA 6)
    - lambda-es6.js

- style: slate
  heading: Assign functions to variables
  code:
    - (Clojure)
    - square.clj
    - (JavaScript)
    - square.js

- style: mold
  heading: Pass functions to functions
  code:
    - (Clojure)
    - square-map.clj
    - (JavaScript)
    - square-map.js

- style: slate
  heading: Return functions from functions
  code:
    - (Clojure)
    - multiply-by.clj

- style: mold
  heading: Return functions from functions
  code:
    - (JavaScript)
    - multiply-by.js
    - debounce.js

- style: clay
  code: curry1.js

- style: clay
  code: curry2.js

- style: purple
  code: curry3.js

- style: purple
  code: curry4.js

- style: purple
  code: curry5.js

- style: purple
  code: curry6.js

- style: slate
  code: partial1.js

- style: slate
  code: partial2.js

- style: mold
  title: Add sum curry
  code:
    - (Haskell)
    - add.hs

- style: clay
  text: f(x) = ?, g(x) = ?
  image: images/cat.jpg
  notes: |
    Exercise with two people. One person is f(x) = 2x + 1 another is g(x) = 2x + y where y
    is the last result from f(x). The audience's job is to guess the implementations by poking at the
    functions with inputs. The functions each take turns answering. The audience shouts "2!" and then
    f replies "5". The audience says "3?" and g replies "11!" (2 * 3 + 5). The goal is to demonstrate that
    side effects are hard.

- style: mold
  heading: Referential Transparency
  text: |
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>

- style: clay
  heading: NOT Referential Transparency
  text: |
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>
    f('cat') => 'purrrrrr'

- style: slate
  title: ReactJS
  text: props + state = dom
  code: react.js

- style: purple
  code: mutate1.js

- style: purple
  code: mutate2.js

- style: purple
  heading: Mutable State is Hard
  bullets:
    - concurrency/async
    - complex mental models (state soup)
    - accidental reference passing (and leaks)
    - complex test setups

- heading: Recursion
  style: slate
  code: [(Haskell), fib.hs, (JavaScript), fib.js]

- style: slate
  title: List Processing
  code:
    - (Clojure)
    - list-processing.clj

- style: slate
  title: Map
  code:
    - map-explained.js

- style: slate
  title: Reduce
  code:
    - reduce-explained.js

- style: purple
  title: List Processing
  text: Here is some data
  code: robot1.js
  notes: Total height of Star Wars robots

- style: purple
  title: List Processing
  text: Underscore.js / Lo-Dash
  code: robot2.js

- style: purple
  title: List Processing
  text: Functions are building blocks
  code: robot3.js
  notes: Total height of Star Wars robots

- style: purple
  title: List Processing
  text: That's better
  code: robot4.js

- style: clay
  title: Composition
  text: _.compose(f, g, h) is f(g(h(x)))
  code: compose1.js

- style: clay
  title: The reusable chain
  code:
    - robot5.js

- style: clay
  title: Curried Scoreunder
  code:
    - robot6.js

- heading: Learn More!
  bullets:
    - Haskell
    - Clojure (Lisp)
    - Erlang/Elixir
