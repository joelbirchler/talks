- style: clay
  title: Function Oriented JavaScript
  notes: |
    I call this talk "Function Oriented JavaScript", but we're really going to be looking at other
    functional languages and attempting to extract good habits from them and apply them to JavaScript.

- heading: TODO
  bullets:
    - Remove Koala examples (use ES5 or Haskell or Underscore)
    - Expand on currying (build example of why)
    - Demo bind (both reasons) and _.partial
    - React examples
    - Mutatable state exercise

- heading: λ
  code:
    - (Haskell)
    - lambda.hs
    - (Clojure)
    - lambda.clj
    - (Erlang)
    - lambda.erl

- heading: λ
  code:
    - (Ruby 1.9)
    - lambda.rb
    - (Java 8)
    - lambda.java
    - (JavaScript)
    - lambda.js

- style: slate
  heading: Assign functions to variables
  code:
    - (Clojure)
    - square.clj
    - (JavaScript)
    - square.js

- style: mold
  heading: Pass functions to functions
  code:
    - (Clojure)
    - square-map.clj
    - (JavaScript)
    - square-map.js

- style: slate
  heading: Return functions from functions
  code:
    - (Clojure)
    - multiply-by.clj

- style: mold
  heading: Return functions from functions
  code:
    - (JavaScript)
    - multiply-by.js
    - debounce.js

- style: clay
  heading: Currying
  text: |
     -> x, y { x + y}.(2,4) is same as ->x { -> y { x + y }.(2)(4)
     then move to autocurrying, then show haskell

- style: mold
  title: Add sum curry
  code:
    - (In oOo...)
    - sum-curry1.js
    - (Underscore's argument order is silly...)
    - sum-curry2.js
  notes: Explain currying better and use bind instead of oOo.

- style: mold
  title: Add sum curry
  code:
    - (Haskell)
    - add.hs

- style: clay
  text: f(x) = ?, g(x) = ?
  image: images/cat.jpg
  notes: |
    Exercise with two people. One person is f(x) = 2x + 1 another is g(x) = 2x + y where y
    is the last result from f(x). The audience's job is to guess the implementations by poking at the
    functions with inputs. The functions each take turns answering. The audience shouts "2!" and then
    f replies "5". The audience says "3?" and g replies "11!" (2 * 3 + 5). The goal is to demonstrate that
    side effects are hard.

- style: mold
  heading: Referential Transparency
  text: |
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>

- style: clay
  heading: NOT Referential Transparency
  text: |
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>
    f('cat') => 'meow' <br/>
    f('cat') => 'purrrrrr'

- style: slate
  text: Referential Transparency with ReactJS

- style: purple
  heading: Mutable State is Hard
  notes: |
    TODO
    1. Show a standard mutative loop
    2. Show a recursive non-mutative loop (possibly building with cons, first, rest)
    3. WHY??
        x = 5; x = x + 1 (woah! wait! I thought x was 5?) ... oo encapsulation of state vs functional anti-state (react, etc might be good here)
        jQuery soup
    4. React

- heading: Recursion
  style: slate
  code: [(Haskell), fib.hs, (JavaScript), fib.js]

- style: slate
  title: List Processing
  code:
    - (Clojure)
    - list-processing.clj

- style: slate
  title: Map
  code:
    - map-explained.js

- style: slate
  title: Reduce
  code:
    - reduce-explained.js

- style: slate
  title: Filter
  code:
    - (filter-explained.js)

- style: purple
  title: List Processing
  text: Here is some data
  code: robot1.js
  notes: Total height of Star Wars robots

- style: purple
  title: List Processing
  text: Underscore.js / Lo-Dash
  code: robot2.js

- style: purple
  title: List Processing
  text: Functions are building blocks
  code: robot3.js
  notes: Total height of Star Wars robots

- style: purple
  title: List Processing
  text: That's better
  code: robot4.js
  notes: Explain with chaining with var a = f(); var b = g(a); var c = h(b);

- title: Remember currying?

- title: Composition
  text: |
    TODO: show compose implementation
    notes: compose(f, g, h) => f(g(h(x)))

- style: clay
  code:
    - (Compose is the reusable chain)
    - (Can this look cleaner?)
    - robot5.js

- heading: Learn More!
  bullets:
    - Haskell
    - Clojure (Lisp)
    - Erlang/Elixir
